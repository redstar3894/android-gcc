/* params.def - Run-time parameters.
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
   Written by Mark Mitchell <mark@codesourcery.com>.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

/* This file contains definitions for language-independent
   parameters.  The DEFPARAM macro takes 6 arguments:

     - The enumeral corresponding to this parameter.

     - The name that can be used to set this parameter using the 
       command-line option `--param <name>=<value>'.

     - A help string explaining how the parameter is used.

     - A default value for the parameter.

     - The minimum acceptable value for the parameter.

     - The maximum acceptable value for the parameter (if greater than
     the minimum).

   Be sure to add an entry to invoke.texi summarizing the parameter.  */

/* The maximum structure size at which the scalar replacement of
   aggregates (SRA) pass will perform block copies.  The default
   value, 0, implies that GCC will select the most appropriate size
   itself.  */
DEFPARAM (PARAM_SRA_MAX_STRUCTURE_SIZE,
	  "sra-max-structure-size",
	  "The maximum structure size (in bytes) for which GCC will "
	  "use by-element copies",
	  0, 0, 0)

/* The maximum number of structure fields which the SRA pass will
   instantiate to avoid block copies.  The default value, 0, implies
   that GCC will select the appropriate value itself.  */
DEFPARAM (PARAM_SRA_MAX_STRUCTURE_COUNT,
	  "sra-max-structure-count",
	  "The maximum number of structure fields for which GCC will "
	  "use by-element copies",
	  0, 0, 0)

/* The ratio between instantiated fields and the complete structure
   size.  We say that if the ratio of the number of bytes in
   instantiated fields to the number of bytes in the complete
   structure exceeds this parameter, or if the number of instantiated
   fields to the total number of fields exceeds this parameter, then
   block copies are not used.  The default is 75%.  */
DEFPARAM (PARAM_SRA_FIELD_STRUCTURE_RATIO,
	  "sra-field-structure-ratio",
	  "The threshold ratio between instantiated fields and the total structure size",
	  75, 0, 100)

/* The threshold ratio between current and hottest structure counts.
   We say that if the ratio of the current structure count, 
   calculated by profiling, to the hottest structure count 
   in the program is less than this parameter, then structure
   reorganization is not applied. The default is 10%.  */
DEFPARAM (PARAM_STRUCT_REORG_COLD_STRUCT_RATIO,
	  "struct-reorg-cold-struct-ratio",
	  "The threshold ratio between current and hottest structure counts",
	  10, 0, 100)

/* When branch is predicted to be taken with probability lower than this
   threshold (in percent), then it is considered well predictable. */
DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,
	  "predictable-branch-outcome",
	  "Maximal esitmated outcome of branch considered predictable",
	  2, 0, 50)

/* The single function inlining limit. This is the maximum size
   of a function counted in internal gcc instructions (not in
   real machine instructions) that is eligible for inlining
   by the tree inliner.
   The default value is 450.
   Only functions marked inline (or methods defined in the class
   definition for C++) are affected by this.
   There are more restrictions to inlining: If inlined functions
   call other functions, the already inlined instructions are
   counted and once the recursive inline limit (see 
   "max-inline-insns" parameter) is exceeded, the acceptable size
   gets decreased.  */
DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,
	  "max-inline-insns-single",
	  "The maximum number of instructions in a single function eligible for inlining",
	  450, 0, 0)

/* The single function inlining limit for functions that are
   inlined by virtue of -finline-functions (-O3).
   This limit should be chosen to be below or equal to the limit
   that is applied to functions marked inlined (or defined in the
   class declaration in C++) given by the "max-inline-insns-single"
   parameter.
   The default value is 450.  */
DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,
	  "max-inline-insns-auto",
	  "The maximum number of instructions when automatically inlining",
	  450, 0, 0)

DEFPARAM (PARAM_INLINE_LIMIT_INCREASE_WITH_PROFILE,
	  "inline-limit-increase-with-profile",
	  "The percentage increase in maximum inlined function size if profile information is available.",
	  100, 0, 0)

DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE,
	  "max-inline-insns-recursive",
	  "The maximum number of instructions inline function can grow to via recursive inlining",
	  450, 0, 0)

DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO,
	  "max-inline-insns-recursive-auto",
	  "The maximum number of instructions non-inline function can grow to via recursive inlining",
	  450, 0, 0)

DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH,
	  "max-inline-recursive-depth",
	  "The maximum depth of recursive inlining for inline functions",
	  8, 0, 0)

DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO,
	  "max-inline-recursive-depth-auto",
	  "The maximum depth of recursive inlining for non-inline functions",
	  8, 0, 0)

DEFPARAM (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY,
	  "min-inline-recursive-probability",
	  "Inline recursively only when the probability of call being executed exceeds the parameter",
	  10, 0, 0)

/* If a callsite is cold, but the callee contains hot code it can be
advantageous to inline the callsite because important context can be
propagated to the hot code.  This parameter sets the minimum threshold
as a fraction of global maximum count for the cold callsite to be
inlined of the following value:

(maximum BB count in callee) * (callsite count) / (callee execution count)

Roughly, this is the expected maximum count of any BB in the callee if
called through this callsite.  */
DEFPARAM (PARAM_MIN_COUNT_FRACTION_FOR_INLINE_COLD,
	  "min-count-fraction-for-inline-cold",
	  "Minimum expected count in a hot callee from a cold callsite for it to be an inline canditate, as a fraction of maximum count.",
	  10, 0, 0)

DEFPARAM (PARAM_INLINE_PRIORITY_THRESHOLD,
	  "inline-priority-threshold",
	  "the maximum priority (growth/frequency) of a non-inline callsite to be inlined without -finline-functions",
	  3500, 0, 0)

DEFPARAM (PARAM_INLINE_FUNCTION_SIZE_ADJUSTMENT,
	  "inline-function-size-adjustment",
	  "Number of extra insns to use in inliner function size estimate to account for prologue, epilogue, and function alignment",
	  20, 0, 0)

DEFPARAM (PARAM_INLINE_ADDRESS_TAKEN_FUNCTION_EMIT_PROBABILITY,
	  "inline-address-taken-function-emit-probability",
	  "Probability that a function whose address is taken will be emitted in the final binary if all callsites in this unit are inlined",
	  75, 0, 100)

DEFPARAM (PARAM_INLINE_ADDRESS_NOT_TAKEN_FUNCTION_EMIT_PROBABILITY,
	  "inline-address-not-taken-function-emit-probability",
	  "Probability that a function whose address is not taken will be emitted in the final binary if all callsites in this unit are inlined",
	  15, 0, 100)

DEFPARAM (PARAM_INLINE_CONST_PARAM_ADJUSTMENT,
	  "inline-const-param-adjustment",
	  "Adjustment in percent to the inlining priority of a callsite for each constant parameter",
	  0, 0, 0)


/* Parameters controlling the growth of hot components of the call
   graph.  The size of a hot component (in internal gcc instructions)
   is the total of all instructions within hot basic blocks of the
   call graph nodes in the hot components.  */
DEFPARAM(PARAM_LARGE_HOT_COMPONENT_INSNS,
	 "large-hot-component-insns",
	 "The size in insns for a hot component to be considered large, and thus have limits on its growth",
	 4000, 0, 0)
DEFPARAM(PARAM_HOT_COMPONENT_GROWTH,
	 "hot-component-growth",
	 "The maximum growth (in percent) of a hot component",
	 5, 0, 0)

/* Limit the number of expansions created by the variable expansion
   optimization to avoid register pressure.  */
DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,
	  "max-variable-expansions-in-unroller",
	  "If -fvariable-expansion-in-unroller is used, the maximum number of times that an individual variable will be expanded during loop unrolling",
          1, 0, 0)
     
/* Limit loop autovectorization to loops with large enough iteration count.  */
DEFPARAM (PARAM_MIN_VECT_LOOP_BOUND,
	  "min-vect-loop-bound",
	  "If -ftree-vectorize is used, the minimal loop bound of a loop to be considered for vectorization",
	  1, 1, 0)

/* The maximum number of instructions to consider when looking for an
   instruction to fill a delay slot.  If more than this arbitrary
   number of instructions is searched, the time savings from filling
   the delay slot will be minimal so stop searching.  Increasing
   values mean more aggressive optimization, making the compile time
   increase with probably small improvement in executable run time.  */
DEFPARAM (PARAM_MAX_DELAY_SLOT_INSN_SEARCH,
	  "max-delay-slot-insn-search",
	  "The maximum number of instructions to consider to fill a delay slot",
	  100, 0, 0)

/* When trying to fill delay slots, the maximum number of instructions
   to consider when searching for a block with valid live register
   information.  Increasing this arbitrarily chosen value means more
   aggressive optimization, increasing the compile time.  This
   parameter should be removed when the delay slot code is rewritten
   to maintain the control-flow graph.  */
DEFPARAM(PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,
	 "max-delay-slot-live-search",
	 "The maximum number of instructions to consider to find accurate live register information",
	 333, 0, 0)

/* This parameter limits the number of branch elements that the 
   scheduler will track anti-dependencies through without resetting
   the tracking mechanism.  Large functions with few calls or barriers 
   can generate lists containing many 1000's of dependencies.  Generally 
   the compiler either uses all available memory, or runs for far too long.  */
DEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,
	 "max-pending-list-length",
	 "The maximum length of scheduling's pending operations list",
	 32, 0, 0)

DEFPARAM(PARAM_LARGE_FUNCTION_HOT_INSNS,
	 "large-function-hot-insns",
	 "The size of hot function regions to be considered large",
	 640, 0, 0)
DEFPARAM(PARAM_LARGE_FUNCTION_INSNS,
	 "large-function-insns",
	 "The size of function body to be considered large",
	 2700, 0, 0)
DEFPARAM(PARAM_LARGE_FUNCTION_GROWTH,
	 "large-function-growth",
	 "Maximal growth due to inlining of large function (in percent)",
	 100, 0, 0)
DEFPARAM(PARAM_LARGE_UNIT_INSNS,
	 "large-unit-insns",
	 "The size of translation unit to be considered large",
	 10000, 0, 0)
DEFPARAM(PARAM_INLINE_UNIT_GROWTH,
	 "inline-unit-growth",
	 "how much can given compilation unit grow because of the inlining (in percent)",
	 30, 0, 0)
DEFPARAM(PARAM_IPCP_UNIT_GROWTH,
	 "ipcp-unit-growth",
	 "how much can given compilation unit grow because of the interprocedural constant propagation (in percent)",
	 10, 0, 0)
DEFPARAM(PARAM_INLINE_CALL_COST,
	 "inline-call-cost",
	 "expense of call operation relative to ordinary arithmetic operations",
	 12, 0, 0)
DEFPARAM(PARAM_LARGE_STACK_FRAME,
	 "large-stack-frame",
	 "The size of stack frame to be considered large",
	 16000, 0, 0)
DEFPARAM(PARAM_STACK_FRAME_GROWTH,
	 "large-stack-frame-growth",
	 "Maximal stack frame growth due to inlining (in percent)",
	 0, 0, 0)

/* The GCSE optimization will be disabled if it would require
   significantly more memory than this value.  */
DEFPARAM(PARAM_MAX_GCSE_MEMORY,
	 "max-gcse-memory",
	 "The maximum amount of memory to be allocated by GCSE",
	 50 * 1024 * 1024, 0, 0)
/* The number of repetitions of copy/const prop and PRE to run.  */
DEFPARAM(PARAM_MAX_GCSE_PASSES,
	"max-gcse-passes",
	"The maximum number of passes to make when doing GCSE",
	1, 1, 0)
/* This is the threshold ratio when to perform partial redundancy
   elimination after reload. We perform partial redundancy elimination
   when the following holds:
   (Redundant load execution count)
   ------------------------------- >= GCSE_AFTER_RELOAD_PARTIAL_FRACTION
   (Added loads execution count)					  */
DEFPARAM(PARAM_GCSE_AFTER_RELOAD_PARTIAL_FRACTION,
	"gcse-after-reload-partial-fraction",
	"The threshold ratio for performing partial redundancy elimination after reload",
        3, 0, 0)
/* This is the threshold ratio of the critical edges execution count compared to
   the redundant loads execution count that permits performing the load
   redundancy elimination in gcse after reload.  */
DEFPARAM(PARAM_GCSE_AFTER_RELOAD_CRITICAL_FRACTION,
	"gcse-after-reload-critical-fraction",
	"The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload",
        10, 0, 0)
/* This parameter limits the number of insns in a loop that will be unrolled,
   and by how much the loop is unrolled.
   
   This limit should be at most half of the peeling limits:  loop unroller
   decides to not unroll loops that iterate fewer than 2*number of allowed
   unrollings and thus we would have loops that are neither peeled or unrolled
   otherwise.  */
DEFPARAM(PARAM_MAX_UNROLLED_INSNS,
	 "max-unrolled-insns",
	 "The maximum number of instructions to consider to unroll in a loop",
	 200, 0, 0)
/* This parameter limits how many times the loop is unrolled depending
   on number of insns really executed in each iteration.  */
DEFPARAM(PARAM_MAX_AVERAGE_UNROLLED_INSNS,
	 "max-average-unrolled-insns",
	 "The maximum number of instructions to consider to unroll in a loop on average",
	 80, 0, 0)
/* The maximum number of unrollings of a single loop.  */
DEFPARAM(PARAM_MAX_UNROLL_TIMES,
	"max-unroll-times",
	"The maximum number of unrollings of a single loop",
	8, 0, 0)
/* The maximum number of insns of a peeled loop.  */
DEFPARAM(PARAM_MAX_PEELED_INSNS,
	"max-peeled-insns",
	"The maximum number of insns of a peeled loop",
	400, 0, 0)
/* The maximum number of peelings of a single loop.  */
DEFPARAM(PARAM_MAX_PEEL_TIMES,
	"max-peel-times",
	"The maximum number of peelings of a single loop",
	16, 0, 0)
/* The maximum number of insns of a peeled loop.  */
DEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS,
	"max-completely-peeled-insns",
	"The maximum number of insns of a completely peeled loop",
	400, 0, 0)
/* The maximum number of insns of a peeled loop, when feedback
   information is available.  */
DEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS_FEEDBACK,
	"max-completely-peeled-insns-feedback",
	"The maximum number of insns of a completely peeled loop when profile "
         "feedback is available",
	600, 0, 0)
/* The maximum number of peelings of a single loop that is peeled completely.  */
DEFPARAM(PARAM_MAX_COMPLETELY_PEEL_TIMES,
	"max-completely-peel-times",
	"The maximum number of peelings of a single loop that is peeled completely",
         8, 0, 0)
/* The maximum number of peelings of a single loop that is peeled
   completely, when feedback information is available.  */
DEFPARAM(PARAM_MAX_COMPLETELY_PEEL_TIMES_FEEDBACK,
	"max-completely-peel-times-feedback",
	"The maximum number of peelings of a single loop that is peeled "
         "completely, when profile feedback is available",
	16, 0, 0)
/* The maximum number of insns of a peeled loop that rolls only once.  */
DEFPARAM(PARAM_MAX_ONCE_PEELED_INSNS,
	"max-once-peeled-insns",
	"The maximum number of insns of a peeled loop that rolls only once",
	400, 0, 0)
/* The maximum number of insns of a peeled loop that rolls only once,
   when feedback information is available..  */
DEFPARAM(PARAM_MAX_ONCE_PEELED_INSNS_FEEDBACK,
	"max-once-peeled-insns-feedback",
	"The maximum number of insns of a peeled loop that rolls only once, "
         "when profile feedback is available",
         600, 0, 0)

/* The maximum number of insns of an unswitched loop.  */
DEFPARAM(PARAM_MAX_UNSWITCH_INSNS,
	"max-unswitch-insns",
	"The maximum number of insns of an unswitched loop",
	50, 0, 0)
/* The maximum level of recursion in unswitch_single_loop.  */
DEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,
	"max-unswitch-level",
	"The maximum number of unswitchings in a single loop",
	3, 0, 0)

/* The maximum number of iterations of a loop the brute force algorithm
   for analysis of # of iterations of the loop tries to evaluate.  */
DEFPARAM(PARAM_MAX_ITERATIONS_TO_TRACK,
	"max-iterations-to-track",
	"Bound on the number of iterations the brute force # of iterations analysis algorithm evaluates",
	1000, 0, 0)
/* A cutoff to avoid costly computations of the number of iterations in
   the doloop transformation.  */
DEFPARAM(PARAM_MAX_ITERATIONS_COMPUTATION_COST,
	"max-iterations-computation-cost",
	"Bound on the cost of an expression to compute the number of iterations",
	10, 0, 0)

/* This parameter is used to tune SMS MAX II calculations.  */
DEFPARAM(PARAM_SMS_MAX_II_FACTOR,
	 "sms-max-ii-factor",
	 "A factor for tuning the upper bound that swing modulo scheduler uses for scheduling a loop",
	 100, 0, 0)
DEFPARAM(PARAM_SMS_DFA_HISTORY,
	 "sms-dfa-history",
	 "The number of cycles the swing modulo scheduler considers when checking conflicts using DFA",
	 0, 0, 0)
DEFPARAM(PARAM_SMS_LOOP_AVERAGE_COUNT_THRESHOLD,
	 "sms-loop-average-count-threshold",
	 "A threshold on the average loop count considered by the swing modulo scheduler",
	 0, 0, 0)

DEFPARAM(HOT_BB_COUNT_FRACTION,
	 "hot-bb-count-fraction",
	 "Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot",
	 10000, 0, 0)
DEFPARAM(HOT_BB_FREQUENCY_FRACTION,
	 "hot-bb-frequency-fraction",
	 "Select fraction of the maximal frequency of executions of basic block in function given basic block needs to have to be considered hot",
	 1000, 0, 0)

DEFPARAM (PARAM_ALIGN_THRESHOLD,
	  "align-threshold",
	  "Select fraction of the maximal frequency of executions of basic block in function given basic block get alignment",
	  100, 0, 0)

DEFPARAM (PARAM_ALIGN_LOOP_ITERATIONS,
	  "align-loop-iterations",
	  "Loops iterating at least selected number of iterations will get loop alignement.",
	  4, 0, 0)

/* For guessed profiles, the loops having unknown number of iterations
   are predicted to iterate relatively few (10) times at average.
   For functions containing one loop with large known number of iterations
   and other loops having unbounded loops we would end up predicting all
   the other loops cold that is not usually the case.  So we need to artificially
   flatten the profile.  

   We need to cut the maximal predicted iterations to large enough iterations
   so the loop appears important, but safely within HOT_BB_COUNT_FRACTION
   range.  */

DEFPARAM(PARAM_MAX_PREDICTED_ITERATIONS,
	 "max-predicted-iterations",
	 "The maximum number of loop iterations we predict statically",
	 100, 0, 0)
DEFPARAM(TRACER_DYNAMIC_COVERAGE_FEEDBACK,
	 "tracer-dynamic-coverage-feedback",
	 "The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available",
	 95, 0, 100)
DEFPARAM(TRACER_DYNAMIC_COVERAGE,
	 "tracer-dynamic-coverage",
	 "The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is not available",
	 75, 0, 100)
DEFPARAM(TRACER_MAX_CODE_GROWTH,
	 "tracer-max-code-growth",
	 "Maximal code growth caused by tail duplication (in percent)",
	 100, 0, 0)
DEFPARAM(TRACER_MIN_BRANCH_RATIO,
	 "tracer-min-branch-ratio",
	 "Stop reverse growth if the reverse probability of best edge is less than this threshold (in percent)",
	 10, 0, 100)
DEFPARAM(TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK,
	 "tracer-min-branch-probability-feedback",
	 "Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available",
	 80, 0, 100)
DEFPARAM(TRACER_MIN_BRANCH_PROBABILITY,
	 "tracer-min-branch-probability",
	 "Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is not available",
	 50, 0, 100)

/* The maximum number of incoming edges to consider for crossjumping.  */
DEFPARAM(PARAM_MAX_CROSSJUMP_EDGES,
	 "max-crossjump-edges",
	 "The maximum number of incoming edges to consider for crossjumping",
	 100, 0, 0)

/* The minimum number of matching instructions to consider for crossjumping.  */
DEFPARAM(PARAM_MIN_CROSSJUMP_INSNS,
     "min-crossjump-insns",
     "The minimum number of matching instructions to consider for crossjumping",
     5, 0, 0)

/* The maximum number expansion factor when copying basic blocks.  */
DEFPARAM(PARAM_MAX_GROW_COPY_BB_INSNS,
     "max-grow-copy-bb-insns",
     "The maximum expansion factor when copying basic blocks",
     8, 0, 0)

/* The maximum number of insns to duplicate when unfactoring computed gotos.  */
DEFPARAM(PARAM_MAX_GOTO_DUPLICATION_INSNS,
     "max-goto-duplication-insns",
     "The maximum number of insns to duplicate when unfactoring computed gotos",
     8, 0, 0)

/* The maximum length of path considered in cse.  */
DEFPARAM(PARAM_MAX_CSE_PATH_LENGTH,
	 "max-cse-path-length",
	 "The maximum length of path considered in cse",
	 10, 0, 0)
DEFPARAM(PARAM_MAX_CSE_INSNS,
	 "max-cse-insns",
	 "The maximum instructions CSE process before flushing",
	 1000, 0, 0)

/* The cost of expression in loop invariant motion that is considered
   expensive.  */
DEFPARAM(PARAM_LIM_EXPENSIVE,
	 "lim-expensive",
	 "The minimum cost of an expensive expression in the loop invariant motion",
	 20, 0, 0)

/* Bound on number of candidates for induction variables below that
   all candidates are considered for each use in induction variable
   optimizations.  */

DEFPARAM(PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,
	 "iv-consider-all-candidates-bound",
	 "Bound on number of candidates below that all candidates are considered in iv optimizations",
	 30, 0, 0)

/* The induction variable optimizations give up on loops that contain more
   induction variable uses.  */

DEFPARAM(PARAM_IV_MAX_CONSIDERED_USES,
	 "iv-max-considered-uses",
	 "Bound on number of iv uses in loop optimized in iv optimizations",
	 250, 0, 0)

/* If there are at most this number of ivs in the set, try removing unnecessary
   ivs from the set always.  */

DEFPARAM(PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND,
	 "iv-always-prune-cand-set-bound",
	 "If number of candidates in the set is smaller, we always try to remove unused ivs during its optimization",
	 10, 0, 0)

DEFPARAM(PARAM_SCEV_MAX_EXPR_SIZE,
 	 "scev-max-expr-size",
	 "Bound on size of expressions used in the scalar evolutions analyzer",
	 20, 0, 0)

DEFPARAM(PARAM_OMEGA_MAX_VARS,
 	 "omega-max-vars",
	 "Bound on the number of variables in Omega constraint systems",
	 128, 0, 0)

DEFPARAM(PARAM_OMEGA_MAX_GEQS,
 	 "omega-max-geqs",
	 "Bound on the number of inequalities in Omega constraint systems",
	 256, 0, 0)

DEFPARAM(PARAM_OMEGA_MAX_EQS,
 	 "omega-max-eqs",
	 "Bound on the number of equalities in Omega constraint systems",
	 128, 0, 0)

DEFPARAM(PARAM_OMEGA_MAX_WILD_CARDS,
 	 "omega-max-wild-cards",
	 "Bound on the number of wild cards in Omega constraint systems",
	 18, 0, 0)

DEFPARAM(PARAM_OMEGA_HASH_TABLE_SIZE,
 	 "omega-hash-table-size",
	 "Bound on the size of the hash table in Omega constraint systems",
	 550, 0, 0)

DEFPARAM(PARAM_OMEGA_MAX_KEYS,
 	 "omega-max-keys",
	 "Bound on the number of keys in Omega constraint systems",
	 500, 0, 0)

DEFPARAM(PARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS,
 	 "omega-eliminate-redundant-constraints",
	 "When set to 1, use expensive methods to eliminate all redundant constraints",
	 0, 0, 1)

DEFPARAM(PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS,
         "vect-max-version-for-alignment-checks",
         "Bound on number of runtime checks inserted by the vectorizer's loop versioning for alignment check",
         6, 0, 0)

DEFPARAM(PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS,
         "vect-max-version-for-alias-checks",
         "Bound on number of runtime checks inserted by the vectorizer's loop versioning for alias check",
         10, 0, 0)

DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,
	 "max-cselib-memory-locations",
	 "The maximum memory locations recorded by cselib",
	 500, 0, 0)

#ifdef ENABLE_GC_ALWAYS_COLLECT
# define GGC_MIN_EXPAND_DEFAULT 0
# define GGC_MIN_HEAPSIZE_DEFAULT 0
#else
# define GGC_MIN_EXPAND_DEFAULT 30
# define GGC_MIN_HEAPSIZE_DEFAULT 4096
#endif

DEFPARAM(GGC_MIN_EXPAND,
	 "ggc-min-expand",
	 "Minimum heap expansion to trigger garbage collection, as a percentage of the total size of the heap",
	 GGC_MIN_EXPAND_DEFAULT, 0, 0)

DEFPARAM(GGC_MIN_HEAPSIZE,
	 "ggc-min-heapsize",
	 "Minimum heap size before we start collecting garbage, in kilobytes",
	 GGC_MIN_HEAPSIZE_DEFAULT, 0, 0)

#undef GGC_MIN_EXPAND_DEFAULT
#undef GGC_MIN_HEAPSIZE_DEFAULT

DEFPARAM(PARAM_MAX_RELOAD_SEARCH_INSNS,
	 "max-reload-search-insns",
	 "The maximum number of instructions to search backward when looking for equivalent reload",
	 100, 0, 0)

DEFPARAM(PARAM_MAX_ALIASED_VOPS,
         "max-aliased-vops",
	 "The maximum number of virtual operators that a function is allowed to have before triggering memory partitioning heuristics",
	 100, 0, 0)

DEFPARAM(PARAM_AVG_ALIASED_VOPS,
    	 "avg-aliased-vops",
	 "The average number of virtual operators that memory statements are allowed to have before triggering memory partitioning heuristics",
	 1, 0, 0)

DEFPARAM(PARAM_MAX_SCHED_REGION_BLOCKS,
	 "max-sched-region-blocks",
	 "The maximum number of blocks in a region to be considered for interblock scheduling",
	 10, 0, 0)

DEFPARAM(PARAM_MAX_SCHED_REGION_INSNS,
	 "max-sched-region-insns",
	 "The maximum number of insns in a region to be considered for interblock scheduling",
	 100, 0, 0)

DEFPARAM(PARAM_MAX_PIPELINE_REGION_BLOCKS,
	 "max-pipeline-region-blocks",
	 "The maximum number of blocks in a region to be considered for interblock scheduling",
	 15, 0, 0)

DEFPARAM(PARAM_MAX_PIPELINE_REGION_INSNS,
	 "max-pipeline-region-insns",
	 "The maximum number of insns in a region to be considered for interblock scheduling",
	 200, 0, 0)

DEFPARAM(PARAM_MIN_SPEC_PROB,
         "min-spec-prob",
         "The minimum probability of reaching a source block for interblock speculative scheduling",
         40, 0, 0)

DEFPARAM(PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS,
         "max-sched-extend-regions-iters",
         "The maximum number of iterations through CFG to extend regions",
         0, 0, 0)

DEFPARAM(PARAM_MAX_SCHED_INSN_CONFLICT_DELAY,
         "max-sched-insn-conflict-delay",
         "The maximum conflict delay for an insn to be considered for speculative motion",
         3, 1, 10)

DEFPARAM(PARAM_SCHED_SPEC_PROB_CUTOFF,
         "sched-spec-prob-cutoff",
         "The minimal probability of speculation success (in percents), so that speculative insn will be scheduled.",
         40, 0, 100)

DEFPARAM(PARAM_SELSCHED_MAX_LOOKAHEAD,
         "selsched-max-lookahead",
         "The maximum size of the lookahead window of selective scheduling",
         50, 0, 0)

DEFPARAM(PARAM_SELSCHED_MAX_SCHED_TIMES,
         "selsched-max-sched-times",
         "Maximum number of times that an insn could be scheduled",
         2, 0, 0)

DEFPARAM(PARAM_SELSCHED_INSNS_TO_RENAME,
         "selsched-insns-to-rename",
         "Maximum number of instructions in the ready list that are considered eligible for renaming",
         2, 0, 0)

DEFPARAM (PARAM_SCHED_MEM_TRUE_DEP_COST,
	  "sched-mem-true-dep-cost",
	  "Minimal distance between possibly conflicting store and load",
	  1, 0, 0)

DEFPARAM(PARAM_MAX_LAST_VALUE_RTL,
	 "max-last-value-rtl",
	 "The maximum number of RTL nodes that can be recorded as combiner's last value",
	 10000, 0, 0)

/* INTEGER_CST nodes are shared for values [{-1,0} .. N) for
   {signed,unsigned} integral types.  This determines N.
   Experimentation shows 256 to be a good value.  */
DEFPARAM (PARAM_INTEGER_SHARE_LIMIT,
	  "integer-share-limit",
	  "The upper bound for sharing integer constants",
	  256, 2, 2)

/* Incremental SSA updates for virtual operands may be very slow if
   there is a large number of mappings to process.  In those cases, it
   is faster to rewrite the virtual symbols from scratch as if they
   had been recently introduced.  This heuristic cannot be applied to
   SSA mappings for real SSA names, only symbols kept in FUD chains.

   PARAM_MIN_VIRTUAL_MAPPINGS specifies the minimum number of virtual
   mappings that should be registered to trigger the heuristic.
   
   PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO specifies the ratio between
   mappings and symbols.  If the number of virtual mappings is
   PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO bigger than the number of
   virtual symbols to be updated, then the updater switches to a full
   update for those symbols.  */
DEFPARAM (PARAM_MIN_VIRTUAL_MAPPINGS,
	  "min-virtual-mappings",
	  "Minimum number of virtual mappings to consider switching to full virtual renames",
	  100, 0, 0)

DEFPARAM (PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO,
	  "virtual-mappings-ratio",
	  "Ratio between virtual mappings and virtual symbols to do full virtual renames",
	  3, 0, 0)

DEFPARAM (PARAM_SSP_BUFFER_SIZE,
	  "ssp-buffer-size",
	  "The lower bound for a buffer to be considered for stack smashing protection",
	  8, 1, 0)

/* When we thread through a block we have to make copies of the
   statements within the block.  Clearly for large blocks the code
   duplication is bad.

   PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS specifies the maximum number
   of statements and PHI nodes allowed in a block which is going to
   be duplicated for thread jumping purposes.

   Some simple analysis showed that more than 99% of the jump
   threading opportunities are for blocks with less than 15
   statements.  So we can get the benefits of jump threading
   without excessive code bloat for pathological cases with the
   throttle set at 15 statements.  */
DEFPARAM (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS,
	  "max-jump-thread-duplication-stmts",
          "Maximum number of statements allowed in a block that needs to be duplicated when threading jumps",
	  15, 0, 0)

/* This is the maximum number of fields a variable may have before the pointer analysis machinery
   will stop trying to treat it in a field-sensitive manner.  
   There are programs out there with thousands of fields per structure, and handling them
   field-sensitively is not worth the cost.  */
DEFPARAM (PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE,
          "max-fields-for-field-sensitive",
	  "Maximum number of fields in a structure before pointer analysis treats the structure as a single variable",
	  0, 0, 0)

DEFPARAM(PARAM_MAX_SCHED_READY_INSNS,
	 "max-sched-ready-insns",
	 "The maximum number of instructions ready to be issued to be considered by the scheduler during the first scheduling pass",
	 100, 0, 0)

/* Prefetching and cache-optimizations related parameters.  Default values are
   usually set by machine description.  */

/* The number of insns executed before prefetch is completed.  */

DEFPARAM (PARAM_PREFETCH_LATENCY,
	 "prefetch-latency",
	 "The number of insns executed before prefetch is completed",
	 200, 0, 0)

/* The number of prefetches that can run at the same time.  */

DEFPARAM (PARAM_SIMULTANEOUS_PREFETCHES,
	  "simultaneous-prefetches",
	  "The number of prefetches that can run at the same time",
	  3, 0, 0)

DEFPARAM (PARAM_MIN_INSN_TO_PREFETCH_RATIO,
	  "min-insn-to-prefetch-ratio",
	  "Min. ratio of insns to prefetches to enable prefetching for "
          "a loop with an unknown trip count",
	  10, 0, 0)

DEFPARAM (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO,
	  "prefetch-min-insn-to-mem-ratio",
	  "Min. ratio of insns to mem ops to enable prefetching in a loop",
	  3, 0, 0)

/* The size of L1 cache in kB.  */

DEFPARAM (PARAM_L1_CACHE_SIZE,
	  "l1-cache-size",
	  "The size of L1 cache",
	  64, 0, 0)

/* The size of L1 cache line in bytes.  */

DEFPARAM (PARAM_L1_CACHE_LINE_SIZE,
	  "l1-cache-line-size",
	  "The size of L1 cache line",
	  32, 0, 0)

/* The size of L2 cache in kB.  */

DEFPARAM (PARAM_L2_CACHE_SIZE,
	  "l2-cache-size",
	  "The size of L2 cache",
	  512, 0, 0)

/* Whether we should use canonical types rather than deep "structural"
   type checking.  Setting this value to 1 (the default) improves
   compilation performance in the C++ and Objective-C++ front end;
   this value should only be set to zero to work around bugs in the
   canonical type system by disabling it.  */

DEFPARAM (PARAM_USE_CANONICAL_TYPES,
	  "use-canonical-types",
	  "Whether to use canonical types",
	  1, 0, 1)

DEFPARAM (PARAM_MAX_PARTIAL_ANTIC_LENGTH,
	  "max-partial-antic-length",
	  "Maximum length of partial antic set when performing tree pre optimization",
	  100, 0, 0)

/* The following is used as a stop-gap limit for cases where really huge
   SCCs blow up memory and compile-time use too much.  If we hit this limit,
   SCCVN and such FRE and PRE will be not done at all for the current
   function.  */

DEFPARAM (PARAM_SCCVN_MAX_SCC_SIZE,
	  "sccvn-max-scc-size",
	  "Maximum size of a SCC before SCCVN stops processing a function",
	  10000, 10, 0)

DEFPARAM (PARAM_IRA_MAX_LOOPS_NUM,
	  "ira-max-loops-num",
	  "max loops number for regional RA",
	  100, 0, 0)

DEFPARAM (PARAM_IRA_MAX_CONFLICT_TABLE_SIZE,
	  "ira-max-conflict-table-size",
	  "max size of conflict table in MB",
	  1000, 0, 0)

/* Switch initialization conversion will refuse to create arrays that are
   bigger than this parameter times the number of switch branches.  */

DEFPARAM (PARAM_SWITCH_CONVERSION_BRANCH_RATIO,
	  "switch-conversion-max-branch-ratio",
	  "The maximum ratio between array size and switch branches for "
	  "a switch conversion to take place",
	  8, 1, 0)

/* Switch to turn on live range shrinking optimization 

   The parameter takes three values: 0, 1, 2. 
   0:  the optimization is turned off.
   1:  the optimization is turned on for regions that are likely
       to have register pressure problem.
   2.  force the optimization for regions.  */

DEFPARAM (PARAM_CONTROL_REG_PRESSURE,
	  "ctrl-regpre",
          "The paramater to control the behavior of the lrs shrinking"
          "phase",
          1, 0, 2)

/* Knob to enable/disable various transformations in LRS.
   
   1: Enable upward code motion;
   2: Enable downward code motion;
   4: Enable tree reshaping;

  The above values can be bitwise-ORed. For instance a value
  of 3 means enabling upward and downward motion only. */

DEFPARAM (PARAM_REG_PRESSURE_CONTROL_MODE,
	  "ctrl-regpre-mode",
          "The parameter to control the behavior of the lrs shrinking"
          "phase",
          7, 1, 7)

/* A performance tuning knob to control register pressure. 
   When the size (in the number of gimple statements) of a basic block 
   in a loop is larger than the threshold specified by this parameter 
   multipled by the number of available registers, live range shrinking
   optimization is kicked in.  */
 
DEFPARAM (PARAM_REG_PRESSURE_MIN_BB_FACTOR,
	  "reg-pressure-min-bb-factor",
          "The parameter to control the behavior of the lrs shrinking"
          "phase",
          3, 1, 10000)

/* Controls the maximum region size (measured in number of gimple
   statements) allowed for live range shrinking.  */
DEFPARAM (PARAM_REG_PRESSURE_MAX_REGION,
	  "reg-pressure-max-region",
          "maximum allowed size of region for live range shrinking",
          3000, 1, 1000000)

/* The minimal size (number of leaves) of the tree to be reshaped
   in the LR shrinking pass.  */

 DEFPARAM (PARAM_REG_PRESSURE_MIN_TREE_TO_RESHAPE,
	  "reg-pressure-min-tree",
          "The parameter to control the behavior of the lrs shrinking"
          "phase",
          5, 1, 100)

/* Avoid doing loop invariant motion on very large loops.  */

DEFPARAM (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,
	  "loop-invariant-max-bbs-in-loop",
	  "max basic blocks number in loop for loop invariant motion",
	  10000, 0, 0)

/* Promote indirect call to conditional direct call only
   when the percentage of the target count over the total
   indirect call count is no smaller than the threshold.  */
DEFPARAM (PARAM_ICALL_PROMOTE_PERCENT_THRESHOLD,
	  "icall-promote-target-percent-threshold",
	  "percentage threshold for direct call promotion"
          " of a callee target",
	  33, 0, 100)

DEFPARAM (PARAM_ICALL_PROMOTE_COUNT_THRESHOLD,
	  "icall-promote-target_count-threshold",
	  "call count threshold for direct call promotion"
          " of a callee target",
	  1, 0, 0)

/* 0: do not always inline icall target:
   other value: always inline icall target when call count
   exceeds this value.
*/
DEFPARAM (PARAM_ALWAYS_INLINE_ICALL_TARGET,
	  "always-inline-icall-target",
	  "force inline indirect call target when promoted",
          0, 0, 0)

/* Force the compiler to be in LIPO mode even there is no
 profile data available. -fripa is also needed. */
DEFPARAM (PARAM_FORCE_LIPO_MODE, 
	  "force-lipo",
	  "force LIPO compilation mode",
          0, 0, 1)

/* Limit max module group size in LIPO mode.  When the value
 is set to 0 (which is the default), there is no limit.  */
DEFPARAM (PARAM_MAX_LIPO_GROUP,
	  "max-lipo-group",
	  "maximum module group size.",
          0, 0, 10000)

/* In LIPO mode, stop processing any further auxiliary modules
   if current memory consumption exceeds this limit (in kb).  */
DEFPARAM (PARAM_MAX_LIPO_MEMORY,
	  "max-lipo-mem",
	  "don't import aux files if memory consumption exceeds this value",
	  2400000, 0, 0)

/* Used for debugging purpose. Tell the compiler to find
   the gcda file in the current directory.  */
DEFPARAM (PARAM_GCOV_DEBUG,
	  "gcov-debug",
	  "Looking for gcda file in current dir.",
	  1, 0, 1)

DEFPARAM (PARAM_MIN_MCF_CANCEL_ITERS,
	  "min-mcf-cancel-iters",
	  "the minimum number of iterations of negative cycle cancellation "
	  "in MCF",
	  10, 1, 0)

DEFPARAM (PARAM_SAMPLEFDO_MCF_HIGH_CONFIDENCE_COST_MULT,
          "samplefdo-mcf-high-confidence-cost-mult",
          "multiply base cost used by mcf by this factor for high confidence "
          "profiles",
          10, 1, 1000)

DEFPARAM (PARAM_SAMPLEFDO_USE_DISCRIMINATORS,
          "samplefdo-use-discrim",
          "use discriminators when doing profile annotation",
          1, 0, 1)
	  
DEFPARAM (PARAM_SAMPLEFDO_LARGE_BLOCK_THRESH,
          "samplefdo-large-block-thresh",
          "Consider a basic block large if it has more than this many gimple "
          "statements in it",
          2, 0, 1000)

DEFPARAM (PARAM_SAMPLEFDO_INST_THRESH,
          "samplefdo-inst-thresh",
          "Consider a basic block reliable if it has more than this many "
          "instructions sampled in it",
          5, 0, 1000)

DEFPARAM (PARAM_REUSEDIST_MEAN_DIST_LARGE_THRESH,
          "reusedist-mean-dist-large-thresh",
          "Generate NTA stringops only if reusedist at least this size",
          10000000, 0, 0)

DEFPARAM (PARAM_REUSEDIST_MEAN_DIST_SMALL_THRESH,
          "reusedist-mean-dist-small-thresh",
          "Force temporal stringops if reusedist at most this size",
          100000, 0, 0)

DEFPARAM (PARAM_REUSEDIST_CALL_COUNT_THRESH,
          "reusedist-call-count-thresh",
          "Generate NTA stringops only if call count at least this large",
          0, 0, 0)

DEFPARAM (PARAM_REUSEDIST_MEMCPY_SIZE_THRESH,
          "reusedist-memcpy-size-thresh",
          "Generate memcpy-nta only if size at least this large",
          4096, 0, 0)

DEFPARAM (PARAM_REUSEDIST_MEMSET_SIZE_THRESH,
          "reusedist-memset-size-thresh",
          "Generate NTA memset only if size at least this large",
          122880, 0, 0)

/* When dumping the call graph only include nodes and edges with a
   count greater than this values.  */
DEFPARAM (PARAM_CGRAPH_DUMP_COUNT_THRESHOLD,
	  "cgraph-dump-count-threshold",
	  "minimum node count for inclusion in VCG call graph dump",
	  0, 0, 0)

/* Only output those call graph edges in .note.callgraph.text sections
   whose count is greater than this value. */
DEFPARAM (PARAM_NOTE_CGRAPH_SECTION_EDGE_THRESHOLD,
	  "note-cgraph-section-edge-threshold",
	  "minimum call graph edge count for inclusion in "
          ".note.callgraph.text section",
	  0, 0, 0)

DEFPARAM (PARAM_PROFILE_GENERATE_SAMPLING_RATE,
	  "profile-generate-sampling-rate",
	  "sampling rate with -fprofile-generate-sampling",
	  100, 0, 2000000000)

DEFPARAM (PARAM_PMU_PROFILE_N_ADDRESS,
	  "pmu_profile_n_addresses",
	  "While doing PMU profiling symbolize this many top addresses.",
	  50, 1, 10000)

DEFPARAM (PARAM_NUMBER_OF_MVERSN_CLONES,
          "num-mversn-clones",
	  "maximum number of functions to be cloned while doing "
          "multiversioning",
	  4, 0, 100)

DEFPARAM (PARAM_MVERSN_CLONE_CGRAPH_DEPTH,
          "mversn-clone-depth",
	  "maximum length of the call graph path to be cloned "
          "while doing multiversioning",
	  1, 0, 5)
/*
Local variables:
mode:c
End:
*/
